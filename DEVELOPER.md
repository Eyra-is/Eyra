# Eyra developer's guide

This document describes the software in more detail, steps to take when using the software/making modifications, a description of how to use the quality control, and how the different components are linked together.

A recommended read as well is the article published on this software, which can be found at [`Docs/Petursson_et_al_2016.pdf`](https://github.com/Eyra-is/Eyra/tree/master/Docs/Petursson_et_al_2016.pdf). It describes many design criteria along with how the software operates and more.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [Development](#development)
  - [Quick description of folder structure](#quick-description-of-folder-structure)
  - [Detailed description of the components](#detailed-description-of-the-components)
  - [Some useful info](#some-useful-info)
  - [Maintaining code](#maintaining-code)
- [Quality Control (QC)](#quality-control-qc)
  - [Firing up the QC](#firing-up-the-qc)
  - [Selecting modules to use](#selecting-modules-to-use)
  - [Creating your own modules](#creating-your-own-modules)
  - [Running QC offline](#running-qc-offline)
- [Evaluation](#evaluation)
  - [Creating sets for evaluation](#creating-sets-for-evaluation)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Development

### Quick description of folder structure

* **AndroidApp**  
    The entire Android app, java code and all. IDE used is Android Studio.

* **Backend**  
    The Flask python code, which handles connections to the MySQL database among other things. Also includes the schema for the database, the entire quality control (QC) and sql code needed for setup. Recordings are saved in `/data/eyra/recordings/` by default (this can be changed in [`app.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/app.py) by changing `app.config['MAIN_RECORDINGS_PATH']`, should be an absolute path). Number of useful scripts in [`scripts/`](https://github.com/Eyra-is/Eyra/tree/master/Backend/scripts) and [`qc/scripts/`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/scripts).

* **Docs**  
    Some additional documentation to this guide and the [README.md](https://github.com/Eyra-is/Eyra/tree/master/README.md).

* **Frontend**  
    The AngularJS code and all related. deploy application using `grunt deploy` in the [`da-webapp/`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp) folder (or [`./Setup/setup.sh --frontend-app`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) from project root). Work in [`src/`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src) is then compiled into `app/`.

* **Local**  
    Locally generated code, generated by the [`Setup/setup.sh`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) script. Used mainly for the apache server.

* **Setup**  
    Setup of the app. Running [`setup.sh`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) installs the webapp from scratch. Includes code for all the components needing a setup, e.g. the apache server, the database setup, the frontend setup and the QC.

### Detailed description of the components

This list is not exhaustive.

* **Android app**  
    The Android app was created with the sole purpose of being a workaround for the observed glitch where recordings through a browser on a phone gave us recordings with a sample rate of 48kHz, but appeared to only contain data up to 16kHz.  
    It does have some pros like easing the acquisition of a device id, but for the most part an incredibly unfortunate resort so far (makes the entire user process much more complicated). 
    
    The setup is a typical auto-setup of a simple app. Here is a list of some of the components, by no means comprehensive  
    * [`AndroidApp/Eyra/app/src/main/`](https://github.com/Eyra-is/Eyra/tree/master/AndroidApp/Eyra/app/src/main/)  
        * [`AndroidManifest.xml`](https://github.com/Eyra-is/Eyra/tree/master/AndroidApp/Eyra/app/src/main/AndroidManifest.xml)  
        * [`java/is/eyra/eyra/*.java`](https://github.com/Eyra-is/Eyra/tree/master/AndroidApp/Eyra/app/src/main/java/is/eyra/eyra)  
            The java code.  
        * [`res/values/strings.xml`](https://github.com/Eyra-is/Eyra/tree/master/AndroidApp/Eyra/app/src/main/res/values/strings.xml)  
            Contains some useful constants, including the current `website_url` used.
            
* **Backend**  
    The entire backend except for the apache server.
    * [`db/`](https://github.com/Eyra-is/Eyra/tree/master/Backend/db)  
        Running [`./Setup/setup.sh --mysqldb`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) typically sets up the entire database.
        * [`invalidate_tokens.sql`](https://github.com/Eyra-is/Eyra/tree/master/Backend/db/invalidate_tokens.sql)  
            This is for the optional feature of marking certain tokens (prompts) invalid in our database. This is because changing the prompt database is hard work (some devices might still have old prompts, and so the ids would all get messed up if you simply deleted the old one and added a new one). So, you can set the `valid` property as `FALSE` in the table `token` for each token you want to stop serving to your devices, but you still maintain its `id` in the database for references.  
            Look at [`scripts/{generate_invalid_token_ids.sh,generate_invalidate_tokens.sh}`](https://github.com/Eyra-is/Eyra/tree/master/Backend/scripts) for how to make this file. You have to uncomment the `source invalidate_tokens.sql` line in [`erase_and_rewind.sql`](https://github.com/Eyra-is/Eyra/tree/master/Backend/db/erase_and_rewind.sql) if you want to utilize this during setup.
        * [`permissions.sql`](https://github.com/Eyra-is/Eyra/tree/master/Backend/db/permissions.sql)  
            During development, you typically access the database locally as root (`mysql -u root -p`), but the code uses a user called `default` without a password which has to have the correct permissions (and no more, just a security concern).
        * [`schema_setup.sql`](https://github.com/Eyra-is/Eyra/tree/master/Backend/db/schema_setup.sql)  
             The main file here is [`schema_setup.sql`](https://github.com/Eyra-is/Eyra/tree/master/Backend/db/schema_setup.sql) which as you might suspect contains the layout of our database. 
        * [`src/`](https://github.com/Eyra-is/Eyra/tree/master/Backend/db/src) and other language specific data  
            [`src`](https://github.com/Eyra-is/Eyra/tree/master/Backend/db/src), [`oldTokens`](https://github.com/Eyra-is/Eyra/tree/master/Backend/db/oldTokens) and more contain language specific data, which should really be placed in [`lang_data`](https://github.com/Eyra-is/Eyra/tree/master/Backend/lang_data) or not at all in the github repo.
    * [`scripts/`](https://github.com/Eyra-is/Eyra/tree/master/Backend/scripts)  
        Number of useful scripts here. Including
        * [`convert_to_eyra_database/`](https://github.com/Eyra-is/Eyra/tree/master/Backend/scripts/convert_to_eyra_database)  
        Which contains code to migrate from other databases to Eyra, you can use it for reference if you need to do the same. Note though, that these migrations might only apply to an earlier version of Eyra, depending on when they were done (these are obviously not maintained).
        * [`firebase/`](https://github.com/Eyra-is/Eyra/tree/master/Backend/scripts/firebase)  
        Code to recover data uploaded as backup to [firebase](https://www.firebase.com/).
    * [`server-interface/`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface)  
        Set up as a pretty basic Flask application. Also contains the entire QC (see large [**section**](https://github.com/Eyra-is/Eyra/blob/master/DEVELOPER.md#quality-control-qc) below the [**Development**](https://github.com/Eyra-is/Eyra/blob/master/DEVELOPER.md#development) section). Entry code is [`app.py`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/app.py) which handles the routes to implement the [`ClientServerAPI.md`](https://github.com/Eyra-is/Eyra/tree/master/ClientServerAPI.md) and all related. An attempt is made to separate the logic using classes in the [`*_handler.py`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface)'s. The [`db_handler`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/db_handler.py) uses code from [`config.py`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/config.py) to connect to our MySQL database.
        * [`auth_handler.py`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/auth_handler.py)  
            Contains allowed `users` to login as admins (under `Settings` in the client app).
        * [`send_mail.py`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/send_mail.py)  
            This is a potentially useful script used to send out an email summary of all gathered data with Eyra on the computer where the mail is sent from. Has all sorts of statistically relevant info, total recordings gathered, recordings by speaker, gender, device etc. Could for example put in a cronjob to send it out every X hours to interested parties for your data collection.

* **Frontend**  
    An AngularJS application and the main component (what the user sees ;)) of Eyra. Setup used the [angular-seed](https://github.com/angular/angular-seed) code to start with. Some original design philosophies: 
    * Favor simplicity over performance unless otherwise needed.
    * Try to keep logic in services and not in controllers.
    * A single controller for each view.
    * App had to be able to be completely offline (appcache was used, should be upgraded to Service Workers, see [TODOS.md](https://github.com/Eyra-is/Eyra/blob/master/TODOS.md)).
    * RESTful communication with server.
    
    Overall documentation is lacking [TODO].  
    
    * [`da-webapp/`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp)  
        A completely useless distinction to have this [`da-webapp`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp) folder :( until they add more components to the Frontend! Stands for "data acquisition webapp". Data acquisition was the project's original title, until Simon came up with Eyra.
        * [`src/`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src)  
            The source, code from here is comiled into the `app/` folder on a [`./Setup/setup.sh --frontend-app`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) or a `grunt deploy` run. Under normal conditions, the application is run from the `app/` folder. Should be pretty straightforward where stuff is here. See **Run webapp straight from `Frontend/da-webapp/src`** in the [**Some useful info**](https://github.com/Eyra-is/Eyra/tree/master/DEVELOPER.md#some-useful-info) section below on how to work straight from source instead of having to compile into `app/` first. Uses Mozilla's [localForage](https://github.com/mozilla/localForage) to store data in the browsers databases on the client side (for offline use, e.g. store cached recordings). The webapp relies heavily on this database working (user data, device data, prompts etc.).
        * `app/`  
            Data generated from [`src/`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src) on a [`./Setup/setup.sh --frontend-app`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) or a `grunt deploy` run. The need for a separate build vs source system is for the most part the application cache (appcache). See [appcache is a douche](http://alistapart.com/article/application-cache-is-a-douchebag). In order to work around all the caveats of the beloved (not) appcache, we need to for example change the filenames of views and scripts on each compile, generate a `app/app.appcache` manifest and more. This is all done in [`Gruntfile.js`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/Gruntfile.js), see more details below. This build process can of course in addition do other useful things such as minifying the javascript code (which it does), and watching changes in the `src/sass/app.scss` file (`grunt watch:sass`). The server that serves the website should serve it from this folder (`app/`).
        * [`Gruntfile.js`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/Gruntfile.js)  
            A file built almost entirely around the appcache. Handles cache breaking file names (appending a date), minification and more. Take care that as of date, if you add some files or modify paths in your application (which are not already added through the glob patterns), you have to add them to the appcache, this is the file to modify, if you want the application to work offline.
   
   **Note:** Since this was based on the [angular-seed](https://github.com/angular/angular-seed) code, you can still run `npm start` if you want to run the application from the built in Angular local server (this feature is not actively tested, just happens to be there). So in addition to that, you could run the Flask application separate on a different port (although you would have to add CORS, and modify the `BACKENDURL` in [`src/app.js`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src/app.js)). It is probably simpler to use our apache server for the entire thing.
    
* **Local**  
    Code initially generated by the [`Setup/setup.sh`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) script. Contains the apache and celery (QC) error logs at `Log/`. Also, as seen in [`Setup`](https://github.com/Eyra-is/Eyra/tree/master/Setup), contains the generated `*.conf` files which `/etc/apache2/sites-enabled/datool.conf` uses (`Local/etc/apache2/vhosts/*.conf`).

* **Setup**  
    Written to simplify the setup of Eyra. Most of the setup can be done by running [`setup.sh`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh), either with the `--all` option or other specific ones (e.g. [`./setup.sh --all --no-ap --no-mysqldb`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) to run everything except the wifi access point and the database setup, or [`./setup.sh --mysqldb`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) to only run the database setup). [`./setup.sh --all`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) runs all components not put specifically as an external component (e.g. `ext-kaldi`).  
    
    **The basic design is this:**   
    The [`setup.sh`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) script contains a list of components, which correspond to folders in [`src`](https://github.com/Eyra-is/Eyra/tree/master/Setup/src) (e.g. [`src/backend-qc`](https://github.com/Eyra-is/Eyra/tree/master/Setup/src/backend-qc) which handles setting up the quality control). Each component can have 
    * pip3 dependencies (`pip3.deps`)
    * apt-get dependencies (`aptitude.deps`)
    * A `custom.deps.sh` script for any additional dependencies.
    * Default configurations for variables to be replaced (`default.conf`)
    * Either in local files (files which end up in `Local`, listed in `local.files`) or
    * Global files (files changed on the system itself, listed in `global.files`).
    * Templates to create the local or global files using the variables in `default.conf` if necessary (`tmpl/*`)
    * A `post_install.sh` script. Run after everything else has been run (dependencies, file creation, etc.). You can put any component specific bash work here.

    As always, looking at the components already there will be a much better lesson than this documentation.

### Some useful info

* A very useful command to restart the Flask application (python backend) is `sudo service apache2 restart`.

* Prompts and tokens are used interchangeably. Originally we called them tokens, but later decided to start calling them prompts.

* Look at [`ClientServerAPI.md`](https://github.com/Eyra-is/Eyra/tree/master/ClientServerAPI.md) in the project root for the REST api which is used to transmit data between client and server. This document needs to be maintained if there are made modifications to the methods therein.

* Logs are located in `Local/Log`. A typical use case would be to for example have a terminal open with a `tail -f {error.log,celery.log}` to watch the apache error log and the celery (QC) log respectively.

* Running [`./Setup/setup.sh --all`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) can be dangerous, because it runs the `--mysqldb` command which deletes the entire database (not the recordings though). Therefore care should be taken when using `--all`, and for example, could run [`./Setup/setup.sh --all --no-mysqldb`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) to leave the database untouched. And of course, remember to backup your database to avoid disasters like this (see [`Backend/scripts/backup_db_and_recs.sh`](https://github.com/Eyra-is/Eyra/tree/master/Backend/scripts/backup_db_and_recs.sh)). 

* Running [`./Setup/setup.sh --all`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) or [`./Setup/setup.sh --ap`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) sets up a wireless access point on your computer. If this is not what you want (your wifi is disabled when this is done for example), a way to enable the wifi is the following:  
    * `sudo nano /etc/NetworkManager/NetworkManager.conf` -> change `managed=false` to `managed=true`
    * `sudo service network-manager restart` 
 
    Wifi should now work again.

* Run webapp straight from `Frontend/da-webapp/src`:  
    For development, it can be nice, not having to do a `grunt deploy` (with minification etc. and the time it takes). In which case, you can work straight from source, however some files need to be modified. These are: 

    * [`Frontend/da-webapp/src/index.html`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src/index.html)  
      **What to do**  
      A sample `index.html` file for this is at [`Frontend/da-webapp/extra_dev_files/development_index.html`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/extra_dev_files/development_index.html). Compare and modify your current [`src/index.html`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src/index.html) file to this (or do a merge). A sample copy of the `index.html` file for use in deployment is at [`Frontend/da-webapp/extra_dev_files/release_index.html`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/extra_dev_files/release_index.html).

    * [`Setup/src/frontend-app/default.conf`](https://github.com/Eyra-is/Eyra/tree/master/Setup/src/frontend-app/default.conf)  
      **What to do**  
      Change the line `YYY_SITEROOT=Frontend/da-webapp/app` to `YYY_SITEROOT=Frontend/da-webapp/src` and run a [`./Setup/setup.sh --frontend-app`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) and a `sudo service apache2 restart`.

      **What does it do**  
      It changes which folder apache uses to serve the application. From the `app/` directory to [`src/`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src).

    After making these modifications, you should be able to run application straight from [`src/`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src). You will also probably want to run `grunt watch:sass` if you make any changes to the [`src/sass/app.scss`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src/sass/app.scss) file.
    
* Monitoring apache (access the server-status page) can be done by navigating to `/diagnostics-status` (`yoursite.com/diagnostics-status`). You are prompted for a password on your first [`Setup/setup.sh --apache`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) run. The username is **admin**. Number of useful things there, like requests per second, idle workers etc.

* If you run into trouble getting data from phones to server (this happened with some older phones, and when server couldn't handle load), you could try making a Firebase account and submitting all the data to there aswell, you can see how we did it, you need to uncomment the `async` and `firebase` script libraries in [`index.html`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src/index.html) and the code at the top of [`services/delivery.service.js`](https://github.com/Eyra-is/Eyra/tree/master/Frontend/da-webapp/src/services/delivery.service.js)->`submitRecordings`.

* You can see an example of converting data from another database/format to Eyra format in [`Backend/scripts/convert_to_eyra_database/non_eyra_data1`](https://github.com/Eyra-is/Eyra/tree/master/Backend/scripts/convert_to_eyra_database/non_eyra_data1)        

### Maintaining code

Most of this should be self explanatory, but if you change code, remember to:

* Write tests or make sure existing tests pass. (for now tests are seriously lacking, but you can run some Frontend tests with `npm test`)
* Change relevant comments.
* Change relevant documentation (for example here in DEVELOPER.md and any other descriptors)
* Rerun `doctoc --notitle DEVELOPER.md` if you modify this file. (manual for now) You can install doctoc by running `sudo npm install -g doctoc`.

## Quality Control (QC)

**NOTE currently, the frontend queries the QC as normal, but doesn't display anything it receives back.**

The quality control is designed to process the recordings and try to improve the quality of gathered data by giving feedback to the user on the quality, allowing him to improve on the recordings he makes.

This QC uses [Celery](http://www.celeryproject.org/) and a task chaining system to handle load and remain scalable (that's the idea anyway). By processing only a batch of recordings at a time, and then putting the continuation back on the queue as a task.  
The QC is located at [`Backend/server-interface/qc`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc).  

See [`qc/celery_config.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/celery_config.py) for configurable parameters, such as how long a process sleeps on an idle task (no more recordings to be processed yet).

QC reports are dumped on disk at `/data/eyra/qc_reports` or as specified in [`Backend/server-interface/qc/celery_config.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/celery_config.py). As well as being saved in the [Redis](http://redis.io/) datastore (Redis is also used as a message broker for Celery).

### Firing up the QC

* The QC needs Kaldi to be installed. This is done by running [`./Setup/setup.sh --ext-kaldi`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh). This could take some time (hrs).
* The QC also needs a worker running constantly. This is for Celery. You need to install Celery and redis-server, this should be in [`Setup/src/backend-qc/*.deps`](https://github.com/Eyra-is/Eyra/tree/master/Setup/src/backend-qc). Running [`./Setup/setup.sh --backend-qc`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh) should install those for you. Then, the worker is run automatically in the background (see `Setup/src/backend-qc/post_install.sh`), logging to `Local/Log/celery.log`. (be careful, still uses loglevel info (might want to change this for release), so the file could get big fast). You shouldn't need to manually kill the workers with this setup, uses celery multi (you can also restart the celery worker by running [`./Setup/setup.sh --backend-qc`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh)).
* In addition, you need to obtain .scp and .ark files containing the decoded graphs (either by running e.g. [`qc/scripts/{Cleanup,Marosijo}GenGraphs.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/scripts) or getting it elsewhere). These are used by Marosijo and Cleanup module. Generating them takes a long time, and depends on the number/length of the token list. Look at [`qc/scripts/genGraphs.sh`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/scripts) for parallelization of these.  
* If you also need the monophone models/tri models/etc for these modules, you can look at [`Backend/scripts/data_prep/run.sh`](https://github.com/Eyra-is/Eyra/tree/master/Backend/scripts/data_prep/run.sh) and then `Backend/scripts/data_prep/local/prepare_*_deployment.sh` to create them from data collected with Eyra.  
Here is an example of the commands needed to run to create the models/files for the Marosijo module:
    * Edit [`run.sh`](https://github.com/Eyra-is/Eyra/tree/master/Backend/scripts/data_prep/run.sh) to use your lexicon and phonemes.txt. Comment out stage 3 (only used for Cleanup).
    * `./run.sh`
    * `./local/lang_add_phones.sh data/local/dict/lexiconp.txt data/lang data/newlang`
    * `./local/make_phone_bigram_fst.sh exp/mono data/newlang local/my_phone_fst`
    * `./local/prepare_marosijo_deployment.sh data/newlang exp/mono local/my_phone_fst 16000 local/marosijo.tgz`

### Selecting modules to use

In order to decide which QC modules to use, you need to modify [`config.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/config.py), both the imports and the `activeModules` dict to include the QC modules you want to use.

If any modules are added/removed to/from `activeModules`, the [`setupActiveModules.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/scripts/setupActiveModules.py) script needs to be run to add them to the relevant places, which is [`celery_handler.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/celery_handler.py) because [`celery_handler.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/celery_handler.py) needs to use its BaseTask to create its own processing task for each module.
Format of adding modules to activeModules:
  `mod=dict(name='UniqueNameModule', task='UniqueNameTask', processFn=qcProcSessionUniqueNameModule)`

For example, I have a module TestModule, which is in [`TestModule.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/modules/TestModule/TestModule.py)
Then I add `TestModule=dict(name='TestModule', task='TestTask', processFn=qcProcSessionTestModule)` to activeModules and add 
```
try:
    # you need to manually add imports here
    from .celery_handler import qcProcSessionTestModule
except SystemError:
    # and here
    qcProcSessionTestModule = None
```
at the top.

Then the script will handle adding: `from .celery_handler import qcProcSessionTestModule` and adding the template code and replacing `@celery.task(base=TestTask)` and `TestModule` with your module in [`celery_handler.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/celery_handler.py).


### Creating your own modules

To add your own QC module (lets call it New), you need to satisfy a couple of criteria;

* Add a file `modules/NewModule/NewModule.py`.
* Look at e.g. [`modules/TestModule/TestModule.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/modules/TestModule/TestModule.py) for reference, but you need to create a class, `NewTask`, which inherits from `celery.Task` and which will be used as a base Task for all subtasks using that QC module. This means, all subtasks have access to the data in the `NewTask` class (see [celery docs](http://docs.celeryproject.org/en/latest/userguide/tasks.html#custom-task-classes) for more details on this).
  * `NewTask` needs to be able to connect to the redis datastore, to modify the report for this QC module for each session. (with key **report/NewModule/session_id** or as specified in [`redis_layout.md`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/redis_layout.md)) It is important that this report be JSON (double quotes people), use e.g. `json.dumps` before writing to redis datastore.
  * `NewTask` needs to define a method, `processBatch` which handles the processing that QC module needs to do. This method, takes as an argument a session id and indices (=[] when no new recordings are to be processed, in which case the function should return `True`) for recordings of that session to process in this batch (this list is stored in redis datastore by QC handler), and the task chaining which Celery uses, expects this processing function to work only on a small batch of recordings at a time (e.g. 5), so as to not take too long and be able to write intermediary results to redis to display on the client app. `processBatch` might take additional arguments, as specified in [`modules/TestModule/TestModule.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/modules/TestModule/TestModule.py).
* Modify the [`config.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/config.py) script, as specified in the [**Selecting modules to use**](https://github.com/Eyra-is/Eyra/blob/master/DEVELOPER.md#selecting-modules-to-use) section.
* Notes:
  * All files in `modules/NewModule/local` will be ignored by git as per [.gitignore](https://github.com/Eyra-is/Eyra/tree/master/Backend/.gitignore)).

### Running QC offline

The QC saves its reports on disk as well as in memory. This is saved to `/data/eyra/qc_reports` or as specified in [`Backend/server-interface/qc/celery_config.py`](https://github.com/Eyra-is/Eyra/tree/master/Backend/server-interface/qc/celery_config.py).

It should be simple to test the QC on a session basis (if the reports don't already exist (they do if you had QC online while the recordings were made)). Simply create a script which queries the correct API endpoint (same as the clients do, see `ClientServerAPI.md`), i.e. `/qc/report/session/<int:sessionId>` for each session you want to generate a QC report for. Take special note though, that you have to routinely check the same sessions again to avoid a timeout (or change the `session_timeout` value in `celery_config.py` and restart celery (e.g. by running [`./Setup/setup.sh --backend-qc`](https://github.com/Eyra-is/Eyra/tree/master/Setup/setup.sh))). The timeout is currently 15 minutes.  
And so said script was made, see [`qc/scripts/runQCOffline.py`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/qc/scripts/runQCOffline.py).  
Depending on your needs you might have to do a `runQCOffline.py --from_session X --to_session Y` a couple of times to get everything. You probably also want to do something like `python3 runQCOffline.py --from_session 1000 --to_session 2000; while true; do python3 runQCOffline.py --requery_sessions --from_session 1000 --to_session 2000; sleep 300; done` to avoid a timeout and modify [`qc/celery_config.py`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/qc/celery_config.py) and set `qc_offline_mode` to `True`. Run `python3 runQCOffline.py --help` for more options.  
Look at `qc/redis_layout.md` to see how you can monitor the redis database during processing. For example, you can run `redis-cli -n 1 -> keys *processing` to see which reports are being processed (or were being processed and encountered an error) and `redis-cli -n 1 -> keys report*` to see which reports are in the redis database but haven't been dumped to disk (you can manually dump using [`qc/scripts/dumpCertainReports.py`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/qc/scripts/dumpCertainReports.py)).

If running on a large batch of recordings, it might be better to skip the timeout and work on a bigger batch size (modifiable in [`qc/celery_config.py`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/qc/celery_config.py)). E.g. change `batch_size` to 500. Then you can skip requerying the sessions to avoid the timeout, and they should be done in big batches. An example script which seemed to perform well was this one (query each 5 sessions from 116706 to 117330 and wait 20 minutes each 5 sessions.):
```
for i in {23342..23466}; do python3 runQCOffline.py --from_session $(( $(( $(( $i - 1 )) * 5 )) + 1 )) --to_session $(( $i * 5 )) --avoid_timeout 99999 --sleep_between 1; sleep 1200; done
```  
This can obviously be different depending on your computer setup. Don't forget to set `qc_big_batch_mode` to `True` in [`qc/celery_config.py`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/qc/celery_config.py). That will ignore the timeout altogether, and dump the report on disk the moment it is ready.  
In dire situations do a `redis-cli -n 1`->`flushdb` (or -n 0). And then restart Celery/apache. Or a computer restart to free memory.

There exist scripts to parse/process these QC dumps (well, mostly those from the Marosijo module, adding other modules might break this). See some useful scripts to this end in [`qc/scripts/process_qc_dumps`](https://github.com/Eyra-is/Eyra/blob/master/Backend/server-interface/qc/scripts/process_qc_dumps) And as an example, to create a sample of 200 recordings taken randomly from May and June along with its analysis from Marosijo see below. You then have to manually locate those recordings (hello `find -name`).

**Example usage:**
```
python3 parse_qc_dump.py /data/eyra/qc_reports/report/MarosijoModule > qc_dump_combined.txt
./choose_qc_dump_combined.sh qc_dump_combined.txt 200 05 06
```

## Evaluation

A feature to allow users to evaluate (grade and comment) on the recording quality of specific recordings.

Located at `yoursite.com/#/evaluation` and with a link to it in the navbar (hamburger).

### Creating sets for evaluation

All you have to do is insert into `evaluation_sets` a label (`eval_set`) and a `recordingId` for all the recordings you want to be part of that set.

A 5 recording set example:
```
INSERT INTO evaluation_sets (eval_set, recordingId)
VALUES 
  ('example_set', 50),
  ('example_set', 51),
  ('example_set', 12),
  ('example_set', 5),
  ('example_set',196);
```